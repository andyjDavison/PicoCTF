# Local Target

## Description
Smash the stack  
Can you overflow the buffer and modify the other local variable? The program is available here. You can view source here. And connect with it using: ```nc saturn.picoctf.net 49814```


## Challenge Information
**Point Value:** 100  
**Category:** Binary Exploitation

## Hints
1. Do anything you can to change num.
2. When you change num, view the value as hexadecimal.

## Solution
We are given a C program that has a ```num = 64``` and looking at the source we can see if we get it to 65 we win:
```C
if( num == 65 ){
    printf("You win!\n");
    fflush(stdout);
    // Open file
    fptr = fopen("flag.txt", "r");
    if (fptr == NULL)
    {
        printf("Cannot open file.\n");
        fflush(stdout);
        exit(0);
    }

    // Read contents from file
    c = fgetc(fptr);
    while (c != EOF)
    {
        printf ("%c", c);
        c = fgetc(fptr);
    }
    fflush(stdout);

    printf("\n");
    fflush(stdout);
    fclose(fptr);
    exit(0);
  }
```
We also notices the use of the gets() function which we can potentially cause a seg fault.
```c
char input[16];
  int num = 64;
  
  printf("Enter a string: ");
  fflush(stdout);
  gets(input);
  printf("\n");
```
Num is initialized to 64 and there is no way to change it, but 65 is 0x41 in hex, which happens to be 'A' in ASCII. We need to figure out where the first byte of num starts, set that to 'A' (which is 65) and stop. We can use the alphabet technique where we pass it certain amount of input and subtract the output from that to find where our num starts. We pass the string ```abcdefghijklmnopqrstuvwxyz```, which gives us num as 31353, which happens to be 0x7A79 in hex which is little endian for 'yz' in ASCII. So we can subtract that yz from our input string, and this is where we can put our 'A' as we found the start of num. This gives us our flag.

## Flag
picoCTF{l0c4l5_1n_5c0p3_fee8ef05}